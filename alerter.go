package accessmon

import (
	"time"
)

// Alert represents an alert generated by the Alerter
type Alert struct {
	Start time.Time
	End   time.Time
	Value float64
}

// IsOngoing returns true if the alert has a start but no end
func (alert *Alert) IsOngoing() bool {
	return !alert.Start.IsZero() && alert.End.IsZero()
}

// Alerter provides sliding window threshold based anomaly detection
// /!\ NOT THREAD SAFE /!\
type Alerter struct {
	window    time.Duration // the sliding window size
	threshold float64       // the threshold to reach

	mark    time.Time // keep track of the last status change
	ongoing *Alert    // keep track of the current alert if any

	alerts []*Alert // keep track of all issued alerts ( legacy )
}

// NewAlerter builds a new Alerter with the given sliding window and threshold
func NewAlerter(window time.Duration, threshold float64) (alerter *Alerter) {
	return &Alerter{window: window, threshold: threshold}
}

// Check the current and update the Alerter internal state machine
// If the value did trigger the start or end of an alert it is returned
// ! Check assumes that the provided value holds for the last continuous period since the last call
func (a *Alerter) Check(now time.Time, value float64) (alert *Alert) {
	if a.mark.IsZero() {
		// The first message needs to initialize the mark
		a.mark = now
	}
	if value >= a.threshold {
		if a.ongoing == nil {
			deadline := a.mark.Add(a.window)
			if now.After(deadline) || now.Equal(deadline) {
				// all the parameters to create a new alert are present
				// we have only received abnormal values since at least full window duration
				a.ongoing = &Alert{Start: now, Value: value}
				a.alerts = append(a.alerts, a.ongoing)

				// Return alert
				alert = a.ongoing

				// Update mark
				a.mark = now
			} else {
				// abnormal value and no ongoing alert but inside the allowed window
				// we just don't update the current mark
			}
		} else {
			// there is an ongoing alert trying to close
			// we have an abnormal value so update the mark
			// see (2)
			a.mark = now
		}
	} else {
		if a.ongoing != nil {
			deadline := a.mark.Add(a.window)
			if now.After(deadline) || now.Equal(deadline) {
				// all the parameters to close the ongoing alert are present
				// we have only received only normal values since at least full window duration
				a.ongoing.End = now

				// Return alert
				alert = a.ongoing

				// Reset ongoing and update mark
				a.ongoing = nil
				a.mark = now
			} else {
				// normal value and ongoing alert but inside the allowed window
				// we just don't update the current mark
			}
		} else {
			// there is no ongoing alert at the moment
			// we have no abnormal value so update the mark
			// see (1)
			a.mark = now
		}
	}

	//fmt.Printf("now : %s, value : %f (%t), mark %s, ongoing :%t, alerts : %d\n", now, value, value > a.threshold, a.mark, a.ongoing != nil, len(a.alerts))

	return alert
}

// Alerts returns all alerts previously issued by the Alerter
func (a *Alerter) Alerts() (alerts []*Alert) {
	return a.alerts
}
